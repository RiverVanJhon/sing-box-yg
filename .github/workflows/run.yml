name: 保活serv00

on:
  schedule:
   - cron: '0 */11 * * *' # 每11小时执行一次
  workflow_dispatch: 

jobs:
  keep_servers_alive:
    runs-on: ubuntu-latest
    env:
    # serv00变量添加规则：
    # 推荐:为确保节点可用性，建议在Serv00网页不设置端口，脚本会随机生成有效端口，首次运行会中断SSH，请把RES设置为n再执行即可
    # RES(必填)：n表示每次不重置部署，y表示每次重置部署。
    # 其他信息在secrets中。
    # SSH_USER(必填)表示serv00账号名。SSH_PASS(必填)表示serv00密码。REALITY表示reality域名(留空表示serv00官方域名：你serv00账号名.serv00.net)。SUUID表示uuid(留空表示随机uuid)。TCP1_PORT表示vless的tcp端口(留空表示随机tcp端口)。TCP2_PORT表示vmess的tcp端口(留空表示随机tcp端口)。UDP_PORT表示hy2的udp端口(留空表示随机udp端口)。HOST(必填)表示登录serv00服务器域名。ARGO_DOMAIN表示argo固定域名(留空表示临时域名)。ARGO_AUTH表示argo固定域名token(留空表示临时域名)。
    # 必填变量：RES、SSH_USER、SSH_PASS、HOST
    # 注意[]"",:这些符号不要乱删，按规律对齐
    # 每行一个{serv00服务器}，一个服务也可，末尾用,间隔，最后一个服务器末尾无需用,间隔
      ACCOUNTS: ${{ secrets.ACCOUNTS }}  # 假设ACCOUNTS是从GitHub Secrets中读取的
      ISRES: '["n", "n"]'  # 直接在代码中定义isres数组，用于管理每个是否重置RES，需匹配ACCOUNTS的数量。
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Install required packages
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass curl jq

      - name: Process each account
        run: |
          count=0  
          ISRES=($(echo "$isres" | jq -r '.[]'))
          for account in $(echo "${ACCOUNTS}" | jq -c '.[]'); do
            count=$((count+1))
            RES=${ISRES[$((count-1))]}  # 根据索引从isres数组中获取RES值
            SSH_USER=$(echo $account | jq -r '.SSH_USER')
            SSH_PASS=$(echo $account | jq -r '.SSH_PASS')
            REALITY=$(echo $account | jq -r '.REALITY')
            SUUID=$(echo $account | jq -r '.SUUID')
            TCP1_PORT=$(echo $account | jq -r '.TCP1_PORT')
            TCP2_PORT=$(echo $account | jq -r '.TCP2_PORT')
            UDP_PORT=$(echo $account | jq -r '.UDP_PORT')
            HOST=$(echo $account | jq -r '.HOST')
            ARGO_DOMAIN=$(echo $account | jq -r '.ARGO_DOMAIN')
            ARGO_AUTH=$(echo $account | jq -r '.ARGO_AUTH') 
            if sshpass -p "$SSH_PASS" ssh -o StrictHostKeyChecking=no "$SSH_USER@$HOST" -q exit; then
              echo "🎉恭喜！✅第【$count】台服务器连接成功！🚀服务器地址：$HOST ，账户名：$SSH_USER"   
              if [ -z "${ARGO_DOMAIN}" ]; then
                check_process="ps aux | grep '[c]onfig' > /dev/null && ps aux | grep [l]ocalhost:$TCP2_PORT > /dev/null"
              else
                check_process="ps aux | grep '[c]onfig' > /dev/null && ps aux | grep '[t]oken $ARGO_AUTH' > /dev/null"
              fi
              if ! sshpass -p "$SSH_PASS" ssh -o StrictHostKeyChecking=no "$SSH_USER@$HOST" "$check_process" || [[ "$RES" =~ ^[Yy]$ ]]; then
                echo "⚠️检测到主进程或者argo进程未启动，或者执行重置"
                echo "⚠️现在开始修复或重置部署……请稍等"
                echo "⚠️提示Error: Process completed with exit code 255中断并退出时，说明设置随机端口完成，请把RES设置为n再执行即可"
                output=$(run_remote_command "$RES" "$SSH_USER" "$SSH_PASS" "${REALITY}" "$SUUID" "$TCP1_PORT" "$TCP2_PORT" "$UDP_PORT" "$HOST" "${ARGO_DOMAIN}" "${ARGO_AUTH}")
                echo "远程命令执行结果：$output"
              else
                echo "🎉恭喜！✅检测到所有进程正常运行中 "
                echo "配置显示如下："
                sshpass -p "$SSH_PASS" ssh -o StrictHostKeyChecking=no "$SSH_USER@$HOST" \
                   "cat domains/\$(whoami).serv00.net/logs/list.txt; \
                    echo '===================================================='" 
              fi
            else
              echo "===================================================="
              echo "💥杯具！❌第【$count】台服务器连接失败！🚀服务器地址：$HOST ，账户名：$SSH_USER"
              echo "⚠️可能账号名、密码、服务器名称输入错误，或者当前服务器在维护中"  
              echo "===================================================="
            fi
          done
